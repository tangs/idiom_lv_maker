///
/// Code generated by jsonToDartModel https://ashamp.github.io/jsonToDartModel/
///
class LevelDataData {
  List<int> posx;
  List<int> posy;
  List<int> answer;
  int hero;
  List<String> idiom;
  int house;
  List<String> word;
  List<int> mask;

  LevelDataData({
    this.posx,
    this.posy,
    this.answer,
    this.hero,
    this.idiom,
    this.house,
    this.word,
    this.mask,
  });
  LevelDataData.fromJson(Map<String, dynamic> json) {
  if (json["posx"] != null) {
  var v = json["posx"];
  var arr0 = List<int>();
  v.forEach((v) {
  arr0.add(v.toInt());
  });
    posx = arr0;
    }
  if (json["posy"] != null) {
  var v = json["posy"];
  var arr0 = List<int>();
  v.forEach((v) {
  arr0.add(v.toInt());
  });
    posy = arr0;
    }
  if (json["answer"] != null) {
  var v = json["answer"];
  var arr0 = List<int>();
  v.forEach((v) {
  arr0.add(v.toInt());
  });
    answer = arr0;
    }
    hero = json["hero"]?.toInt();
  if (json["idiom"] != null) {
  var v = json["idiom"];
  var arr0 = List<String>();
  v.forEach((v) {
  arr0.add(v.toString());
  });
    idiom = arr0;
    }
    house = json["house"]?.toInt();
  if (json["word"] != null) {
  var v = json["word"];
  var arr0 = List<String>();
  v.forEach((v) {
  arr0.add(v.toString());
  });
    word = arr0;
    }
  if (json["mask"] != null) {
  var v = json["mask"];
  var arr0 = List<int>();
  v.forEach((v) {
  arr0.add(v.toInt());
  });
    mask = arr0;
    }
  }
  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = Map<String, dynamic>();
    if (posx != null) {
      var v = posx;
      var arr0 = List();
  v.forEach((v) {
  arr0.add(v);
  });
      data["posx"] = arr0;
    }
    if (posy != null) {
      var v = posy;
      var arr0 = List();
  v.forEach((v) {
  arr0.add(v);
  });
      data["posy"] = arr0;
    }
    if (answer != null) {
      var v = answer;
      var arr0 = List();
  v.forEach((v) {
  arr0.add(v);
  });
      data["answer"] = arr0;
    }
    data["hero"] = hero;
    if (idiom != null) {
      var v = idiom;
      var arr0 = List();
  v.forEach((v) {
  arr0.add(v);
  });
      data["idiom"] = arr0;
    }
    data["house"] = house;
    if (word != null) {
      var v = word;
      var arr0 = List();
  v.forEach((v) {
  arr0.add(v);
  });
      data["word"] = arr0;
    }
    if (mask != null) {
      var v = mask;
      var arr0 = List();
  v.forEach((v) {
  arr0.add(v);
  });
      data["mask"] = arr0;
    }
    return data;
  }
}

class LevelData {
  int id;
  LevelDataData data;

  LevelData({
    this.id,
    this.data,
  });
  LevelData.fromJson(Map<String, dynamic> json) {
    id = json["id"]?.toInt();
    data = json["data"] != null ? LevelDataData.fromJson(json["data"]) : null;
  }
  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = Map<String, dynamic>();
    data["id"] = id;
    if (data != null) {
      data["data"] = this.data.toJson();
    }
    return data;
  }
}

class LocalLevelData {
  int id;
  int levelup;
  int hero;
  int wifenum;
  int house;
  List<String> idiom;
  List<String> words;
  // 0.normal 1.fixed 2.mask 3.no word
  List<int> types;

  LocalLevelData(int id, int levelup, int hero, int wifenum, int house) {
    id = id;
    // levelup = levelup;
    hero = hero;
    // wifenum = wifenum;
    house = house;
    idiom = [];
    words = new List(81);
    words.fillRange(0, 81, "");
    types = new List(81);
    types.fillRange(0, 81, 3);
  }

  bool hasWordCurLv() {
    for (int type in types) {
      if (type != 3) return true;
    }
    return false;
  }

  bool hasWord(int idx) {
    return types[idx] != 3;
  }

  List<int> getIdiomIdx(int idx, bool isHor) {
    List<int> idiom = new List();
    if (hasWord(idx)) {
      idiom.add(idx);
      int col = idx % 9;
      int row = (idx / 9).floor();
      int dest = isHor ? col : row;
      final fun = (int destIdx, bool isFirst) {
        if (hasWord(destIdx)) {
          if (isFirst) {
            idiom.insert(0, destIdx);
          } else {
            idiom.add(destIdx);
          }
          return true;
        } else {
          return false;
        }
      };
      for (int i = dest - 1; i >= 0; --i) {
        int destIdx = isHor ? row * 9 + i : i * 9 + col;
        if (!fun(destIdx, true)) break;
      }
      for (int i = dest + 1; i < 9; ++i) {
        int destIdx = isHor ? row * 9 + i : i * 9 + col;
        if (!fun(destIdx, false)) break;
      }
    }
    return idiom;
  }

  String getIdiom(int idx, bool isHor) {
    String idiom = '';
    List<int> idxs = getIdiomIdx(idx, isHor);
    for (int i = 0; i < idxs.length; ++i) {
      idiom += words[idxs[i]];
    }
    return idiom;
  }

  bool canPushWord(int row, int col, int withoutIdx) {
    if (row < 0 || row > 8 || col < 0 || col > 8) return false;
    int idx = row * 9 + col;
    if (idx == withoutIdx) return true;
    if (col > 0 && (hasWord(idx - 1) && idx - 1 != withoutIdx)) return false;
    if (col < 8 && (hasWord(idx + 1) && idx + 1 != withoutIdx)) return false;
    if (row > 0 && (hasWord(idx - 9) && idx - 9 != withoutIdx)) return false;
    if (row < 8 && (hasWord(idx + 9) && idx + 9 != withoutIdx)) return false;
    return true;
  }

  List<int> getPushIdiomIdxs(int idx, bool isHor) {
    int withoutIdx = hasWord(idx) ? idx : -1;
    List<int> idxs = List();
    int sRow = (idx / 9).floor();
    int sCol = idx % 9;
    for (int i = 0; i < 4; ++i) {
      bool isSucc = true;
      int row = sRow;
      int col = sCol;
      for (int j = 0; j < 4; ++j) {
        if (!canPushWord(row, col, withoutIdx)) isSucc = false;
        if (isHor) col++; else row++;
      }
      if (isSucc) idxs.add(i);
      if (isHor) sCol--; else sRow--;
      if (sCol < 0 || sRow < 0) break;
    }
    return idxs;
  }

  bool hasIdiom(int idx, bool isHor) {
    return getIdiomIdx(idx, isHor).length == 4;
  }

  bool isRemoveable(int idx, bool isHor) {
    List<int> idxs = getIdiomIdx(idx, isHor);
    if (idxs.length == 4) {
      int cnt = 0;
      for (int i = 0; i < idxs.length; ++i) {
        if (hasIdiom(idxs[i], !isHor)) {
          ++cnt;
        }
      }
      return cnt < 2;
    }
    return false;
  }

  void addWord(int idx, String word) {
    words[idx] = word;
    types[idx] = 0;
  }

  void setWord(int idx, String word) {
    if (word.length > 0) {
      if (types[idx] == 3)
        types[idx] = 0;
      words[idx] = word.substring(0, 1);
    } else {
      rmWord(idx);
    }
  }

  void rmWord(int idx) {
    words[idx] = '';
    types[idx] = 3;
  }

  void rmIdiom(int idx, bool isHor) {
    if (isRemoveable(idx, isHor)) {
      List<int> idxs = getIdiomIdx(idx, isHor);
      for (int idx in idxs) {
        if (!hasIdiom(idx, !isHor)) {
          rmWord(idx);
        }
      }
    }
  }

  void addIdiom(int idx, bool isHor, String idiom) {
    for (int i = 0; i < 4; ++i) {
      setWord(idx, idiom[i]);
      types[idx] = 1;
      if (isHor) idx++; else idx += 9;
    }
    // this.idiom.add(idiom);
  }

  void rmAllWord() {
    words.fillRange(0, 81, '');
    types.fillRange(0, 81, 3);
  }

  String getSelecetableInfo(int idx, bool isHor) {
    List<int> idxs = getIdiomIdx(idx, isHor);
    String txt = '';
    if (idxs.length == 4) {
      for (int idx1 in idxs) {
        txt += hasIdiom(idx1, !isHor) ? words[idx1] : '.';
      }
    }
    return txt;
  }

  void updateCurIdioms() {
    idiom.clear();
    Function fun = (int idx, bool isHor) {
      bool has = hasIdiom(idx, isHor);
      if (has) {
        String idiom1 = getIdiom(idx, isHor);
        if (idiom.indexOf(idiom1) == -1) {
          idiom.add(idiom1);
        }
      }
    };
    for (int i = 0; i < 81; ++i) {
      fun(i, true);
      fun(i, false);
    }
  }

  LocalLevelData.fromData(LocalLevelData data) {
    id = data.id;
    levelup = data.levelup;
    hero = data.hero;
    wifenum = data.wifenum;
    house = data.house;
    idiom = [];
    words = new List(81);
    words.fillRange(0, 81, "");
    types = new List(81);
    types.fillRange(0, 81, 3);
  }

  LocalLevelData.fromLevelData(LevelData levelData) {
    id = levelData.id;
    LevelDataData data = levelData.data;
    hero = data.hero;
    idiom = data.idiom;
    house = data.house;
    words = new List(81);
    words.fillRange(0, 81, "");
    types = new List(81);
    types.fillRange(0, 81, 3);
    int len = data.word.length;
    for (int i = 0; i < len; ++i) {
      int pos = data.posx[i] + (8 - data.posy[i]) * 9;
      bool isMask = data.mask.indexOf(i) != -1;
      bool isFixed = data.answer.indexOf(i) == -1;
      words[pos] = data.word[i];
      types[pos] = isMask ? 2: isFixed ? 1 : 0;
    }
  }

  LevelData toLevelData() {
    updateCurIdioms();
    LevelData ld = new LevelData(
      id: id,
      data: new LevelDataData(
          hero: hero,
          idiom: idiom,
          house: house,
      ),
    );
    List<int> posx = new List();
    List<int> posy = new List();
    List<String> word = new List();
    List<int> mask = new List();
    List<int> answer = new List();
    int idx = 0;
    for (int i = 0; i < 81; ++i) {
      int type = types[i];
      if (type != 3) {
        word.add(words[i]);
        posx.add(i % 9);
        posy.add(8 - (i / 9).floor());
        switch (type) {
          case 0: {
            answer.add(idx);
          }
          break;
          case 1: {

          }
          break;
          case 2: {
            mask.add(idx);
          }
          break;
        }
        ++idx;
      }
    }
    LevelDataData data = ld.data;
    data.posx = posx;
    data.posy = posy;
    data.word = word;
    data.mask = mask;
    data.answer = answer;
    return ld;
  }
}
